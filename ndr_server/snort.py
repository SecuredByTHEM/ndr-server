# Copyright (C) 2017  Secured By THEM
# Original Author: Michael Casadevall <mcasadevall@them.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

'''Classes relating to management of data coming from SNORT'''

import ipaddress
import geoip2.database

import ndr
import ndr_server

class TrafficLog(object):
    '''Traffic logs are generated by SNORT listening to all packets, then are consolated
    into a traffic report entry which is stored in the database'''

    def __init__(self, config):
        self.config = config
        self.recorder = None
        self.pg_id = None
        self.traffic_log = None

    @classmethod
    def create_from_message(cls, config, recorder, log_id, message, db_conn=None):
        '''Creates traffic log entries in the database from ingest message,

           Because there's no additional metadata assoicated with traffic logs,
           the message_id is the record of a given traffic log upload'''

        ingest_log = ndr.SnortTrafficLog()
        ingest_log.from_message(message)

        traffic_log = TrafficLog(config)
        traffic_log.recorder = recorder
        traffic_log.traffic_log = ingest_log
        traffic_log.pg_id = log_id

        # Uploaded logs only have consolated traffic, and not the full traffic entries
        for _, traffic_entry in ingest_log.consolated_traffic.items():
            config.database.run_procedure(
                "snort.create_traffic_report",
                [log_id,
                 traffic_entry.src.compressed,
                 traffic_entry.dst.compressed,
                 traffic_entry.ethsrc,
                 traffic_entry.ethdst,
                 traffic_entry.proto.value,
                 traffic_entry.rxpackets,
                 traffic_entry.txpackets,
                 traffic_entry.firstseen],
                existing_db_conn=db_conn)

        return traffic_log

class TrafficReport(object):
    '''Traffic reports are a summary of all traffic to/from a machine consolated by the database
    for us. This class handles holding the traffic report information, and then matching it to
    GeoIP information'''

    def __init__(self, config):
        self.config = config
        self.organization = None
        self.site = None
        self.traffic_dicts = None
        self.statistics_dicts = {}
        self.total_rxpackets = 0
        self.total_txpackets = 0

    @classmethod
    def pull_report_for_time_interval(cls, config, site, seconds_since, db_conn=None):
        '''Pulls the report based on time from the database'''

        traffic_dict = config.database.run_procedure_fetchone(
            "snort.report_traffic_for_site_within_timeperiod",
            [site.pg_id,
             seconds_since],
            existing_db_conn=db_conn)[0]

        t_report = TrafficReport(config)
        t_report.site = site
        t_report.organization = site.get_organization(db_conn=db_conn)
        t_report.traffic_dicts = traffic_dict['consolidated_traffic']

        return t_report

    def process_dicts(self):
        '''Goes through the traffic report, and deletes local network traffic'''

        new_traffic_dicts = []
        geoip_db = geoip2.database.Reader(self.config.geoip_db)

        # We'll simply copy over the information we want, and discard what we don't
        for traffic_dict in self.traffic_dicts:
            # Simple things first, we need to convert src/dst to ipaddress objects
            traffic_dict['src'] = ipaddress.ip_address(traffic_dict['src'])
            traffic_dict['dst'] = ipaddress.ip_address(traffic_dict['dst'])

            # Global IP is what we'll run the GeoIP report on
            global_ip = None

            # We only care about a network if one address is global, and one end isn't
            if (traffic_dict['src'].is_global is True and
                    traffic_dict['dst'].is_global is False):
                global_ip = traffic_dict['src']
            elif (traffic_dict['dst'].is_global is True and
                  traffic_dict['src'].is_global is False):
                global_ip = traffic_dict['dst']
            else:
                # Don't care about this IP
                continue

            # Make sure we're not dealing w/ a multicast address
            if global_ip.is_multicast is True:
                continue

            try:
                # Run the IP through the database and see what we get
                geoip_entry = geoip_db.city(global_ip.compressed)
                traffic_dict['country'] = geoip_entry.country.name
                traffic_dict['subdivision'] = geoip_entry.subdivisions.most_specific.name
                traffic_dict['city'] = geoip_entry.city.name
                new_traffic_dicts.append(traffic_dict)
            except geoip2.errors.AddressNotFoundError:
                # List it as unknown
                traffic_dict['country'] = "Unknown"
                traffic_dict['subdivision'] = None
                traffic_dict['city'] = "Unknown"
                new_traffic_dicts.append(traffic_dict)

        # And clean up after ourselves
        self.traffic_dicts = new_traffic_dicts
        geoip_db.close()

    def generate_statistics(self):
        '''Works out the number of unique destinations, the total packet counts, and breakdown
        of percentages'''

        total_rxpackets = 0
        total_txpackets = 0

        # We'll break traffic down by country, and subdivision, which acts as the primary key
        statistics_dict = {}

        for traffic_dict in self.traffic_dicts:
            country_stats_dict_key = traffic_dict['country']

            # Create the dict if it doesn't exist
            if country_stats_dict_key not in statistics_dict:
                statistics_dict[country_stats_dict_key] = {}
                statistics_dict[country_stats_dict_key]['subdivisions'] = {}
                statistics_dict[country_stats_dict_key]['rxpackets'] = 0
                statistics_dict[country_stats_dict_key]['txpackets'] = 0

            country_dict = statistics_dict[country_stats_dict_key]
            subdivision_dict = None

            # If we have a subdivision, add that too
            if traffic_dict['subdivision'] is not None:
                subdivision_key = traffic_dict['subdivision']

                if subdivision_key not in country_dict:
                    country_dict['subdivisions'][subdivision_key] = {}
                    country_dict['subdivisions'][subdivision_key]['rxpackets'] = 0
                    country_dict['subdivisions'][subdivision_key]['txpackets'] = 0

                # Set the subdivision dict
                subdivision_dict = country_dict['subdivisions'][subdivision_key]

            # Get a running total of the packet counts

            # First, add the packet counts to the total
            total_rxpackets += traffic_dict['rxpackets']
            total_txpackets += traffic_dict['txpackets']

            # Now to the country, add them there
            country_dict['rxpackets'] += traffic_dict['rxpackets']
            country_dict['txpackets'] += traffic_dict['txpackets']

            # and to the subdivision if we have one
            if subdivision_dict is not None:
                subdivision_dict['rxpackets'] += traffic_dict['rxpackets']
                subdivision_dict['txpackets'] += traffic_dict['txpackets']

        # Now work out the percentages per target
        for _, country_entry in statistics_dict.items():
            country_entry['transmit_percentage'] = (
                "{0:.2f}".format(
                    ((country_entry['txpackets'] / total_txpackets) * 100))
            )
            country_entry['receive_percentage'] = (
                "{0:.2f}".format(
                    ((country_entry['rxpackets'] / total_rxpackets) * 100))
            )

            # If we have a subdivision, let's do for them, based on these percentages
            for _, subdivision_entry in country_entry['subdivisions'].items():
                subdivision_entry['transmit_percentage'] = (
                    "{0:.2f}".format(
                        ((subdivision_entry['txpackets'] / country_entry['txpackets']) * 100))
                )
                subdivision_entry['receive_percentage'] = (
                    "{0:.2f}".format(
                        ((subdivision_entry['rxpackets'] / country_entry['rxpackets']) * 100))
                )

        # Save the results to the object
        self.statistics_dicts = statistics_dict
        self.total_rxpackets = total_rxpackets
        self.total_txpackets = total_txpackets

    def generate_report_emails(self):
        '''Generates a report email breaking down traffic by country destination'''

        tr_email = ndr_server.TrafficReportMessage(self.organization, self.site, self)
