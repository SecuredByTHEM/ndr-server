# Copyright (C) 2017  Secured By THEM
# Original Author: Michael Casadevall <mcasadevall@them.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

'''Classes relating to management of data coming from SNORT'''

import ipaddress
import geoip2.database

import ndr
import ndr_server

class TsharkTrafficReport(object):
    '''Traffic logs are generated by listening programs and summarizing all packets,
    then are consolated into a traffic report entry which is stored in the database'''

    def __init__(self, config):
        self.config = config
        self.recorder = None
        self.pg_id = None
        self.traffic_log = None

    @classmethod
    def create_from_message(cls, config, recorder, log_id, message, db_conn=None):
        '''Creates traffic log entries in the database from ingest message,

           Because there's no additional metadata assoicated with traffic logs,
           the message_id is the record of a given traffic log upload'''

        ingest_log = ndr.TrafficReportMessage()
        ingest_log.from_message(message)

        traffic_log = TsharkTrafficReport(config)
        traffic_log.recorder = recorder
        traffic_log.traffic_log = ingest_log
        traffic_log.pg_id = log_id

        for traffic_entry in ingest_log.traffic_entries:
            config.database.run_procedure(
                "traffic_report.create_traffic_report",
                [log_id,
                 traffic_entry.protocol.value,
                 traffic_entry.src_address.compressed,
                 traffic_entry.src_hostname,
                 traffic_entry.src_port,
                 traffic_entry.dst_address.compressed,
                 traffic_entry.dst_hostname,
                 traffic_entry.dst_port,
                 traffic_entry.rx_bytes,
                 traffic_entry.tx_bytes,
                 traffic_entry.start_timestamp,
                 traffic_entry.duration],
                existing_db_conn=db_conn)

        return traffic_log

class TsharkTrafficReportManager(object):
    '''Handles a summary of traffic report messages from the database'''

    def __init__(self, config):
        self.config = config
        self.organization = None
        self.site = None
        self.traffic_dicts = None
        self.statistics_dicts = {}
        self.total_rxpackets = 0
        self.total_txpackets = 0

    @classmethod
    def pull_report_for_time_interval(cls, config, site, seconds_since, db_conn=None):
        '''Pulls the report based on time from the database'''

    def process_dicts(self):
        '''Goes through the traffic report, and deletes local network traffic'''

        new_traffic_dicts = []
        geoip_db = geoip2.database.Reader(self.config.geoip_db)

        # The traffic_dict can be empty if there's no traffic records for a given period
        if self.traffic_dicts is None:
            return False

        # We'll simply copy over the information we want, and discard what we don't
        for traffic_dict in self.traffic_dicts:
            # Simple things first, we need to convert src/dst to ipaddress objects
            traffic_dict['src'] = ipaddress.ip_address(traffic_dict['src'])
            traffic_dict['dst'] = ipaddress.ip_address(traffic_dict['dst'])

            # Global IP is what we'll run the GeoIP report on
            global_ip = None

            # We only care about a network if one address is global, and one end isn't
            if (traffic_dict['src'].is_global is True and
                    traffic_dict['dst'].is_global is False):
                local_ip = traffic_dict['dst']
                global_ip = traffic_dict['src']
            elif (traffic_dict['dst'].is_global is True and
                  traffic_dict['src'].is_global is False):
                local_ip = traffic_dict['src']
                global_ip = traffic_dict['dst']
            else:
                # Don't care about this IP
                continue

            # Make sure we're not dealing w/ a multicast address
            if global_ip.is_multicast is True:
                continue

            try:
                # Run the IP through the database and see what we get
                geoip_entry = geoip_db.city(global_ip.compressed)
                traffic_dict['country'] = geoip_entry.country.name
                traffic_dict['subdivision'] = geoip_entry.subdivisions.most_specific.name
                traffic_dict['city'] = geoip_entry.city.name
                traffic_dict['geoip_found'] = True
                traffic_dict['global_ip'] = global_ip
                traffic_dict['local_ip'] = local_ip
                new_traffic_dicts.append(traffic_dict)
            except geoip2.errors.AddressNotFoundError:
                # List it as unknown
                traffic_dict['country'] = "Unknown"
                traffic_dict['subdivision'] = None
                traffic_dict['city'] = "Unknown"
                new_traffic_dicts.append(traffic_dict)

        # And clean up after ourselves
        self.traffic_dicts = new_traffic_dicts
        geoip_db.close()

        # Confirm we ran successfully
        return True

    def breakdown_traffic_by_internal_ip(self):
        '''Breaks down traffic by machine and destination'''

    def generate_statistics(self):
        '''Works out the number of unique destinations, the total packet counts, and breakdown
        of percentages'''


    def generate_report_emails(self, send=True, db_conn=None):
        '''Generates a report email breaking down traffic by country destination'''

        tr_email = ndr_server.TrafficReportMessage(self.organization, self.site, self)

        if send is True:
            alert_contacts = self.organization.get_contacts(db_conn=db_conn)

            for contact in alert_contacts:
                contact.send_message(
                    tr_email.subject(), tr_email.prepped_message()
                )

        return tr_email
